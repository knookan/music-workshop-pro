{"version":3,"file":"bk.js","sources":["../../../../../node_modules/dagre/lib/position/bk.js"],"sourcesContent":["\"use strict\";\n\nvar _ = require(\"../lodash\");\nvar Graph = require(\"../graphlib\").Graph;\nvar util = require(\"../util\");\n\n/*\n * This module provides coordinate assignment based on Brandes and KÃ¶pf, \"Fast\n * and Simple Horizontal Coordinate Assignment.\"\n */\n\nmodule.exports = {\n  positionX: positionX,\n  findType1Conflicts: findType1Conflicts,\n  findType2Conflicts: findType2Conflicts,\n  addConflict: addConflict,\n  hasConflict: hasConflict,\n  verticalAlignment: verticalAlignment,\n  horizontalCompaction: horizontalCompaction,\n  alignCoordinates: alignCoordinates,\n  findSmallestWidthAlignment: findSmallestWidthAlignment,\n  balance: balance\n};\n\n/*\n * Marks all edges in the graph with a type-1 conflict with the \"type1Conflict\"\n * property. A type-1 conflict is one where a non-inner segment crosses an\n * inner segment. An inner segment is an edge with both incident nodes marked\n * with the \"dummy\" property.\n *\n * This algorithm scans layer by layer, starting with the second, for type-1\n * conflicts between the current layer and the previous layer. For each layer\n * it scans the nodes from left to right until it reaches one that is incident\n * on an inner segment. It then scans predecessors to determine if they have\n * edges that cross that inner segment. At the end a final scan is done for all\n * nodes on the current rank to see if they cross the last visited inner\n * segment.\n *\n * This algorithm (safely) assumes that a dummy node will only be incident on a\n * single node in the layers being scanned.\n */\nfunction findType1Conflicts(g, layering) {\n  var conflicts = {};\n\n  function visitLayer(prevLayer, layer) {\n    var\n      // last visited node in the previous layer that is incident on an inner\n      // segment.\n      k0 = 0,\n      // Tracks the last node in this layer scanned for crossings with a type-1\n      // segment.\n      scanPos = 0,\n      prevLayerLength = prevLayer.length,\n      lastNode = _.last(layer);\n\n    _.forEach(layer, function(v, i) {\n      var w = findOtherInnerSegmentNode(g, v),\n        k1 = w ? g.node(w).order : prevLayerLength;\n\n      if (w || v === lastNode) {\n        _.forEach(layer.slice(scanPos, i +1), function(scanNode) {\n          _.forEach(g.predecessors(scanNode), function(u) {\n            var uLabel = g.node(u),\n              uPos = uLabel.order;\n            if ((uPos < k0 || k1 < uPos) &&\n                !(uLabel.dummy && g.node(scanNode).dummy)) {\n              addConflict(conflicts, u, scanNode);\n            }\n          });\n        });\n        scanPos = i + 1;\n        k0 = k1;\n      }\n    });\n\n    return layer;\n  }\n\n  _.reduce(layering, visitLayer);\n  return conflicts;\n}\n\nfunction findType2Conflicts(g, layering) {\n  var conflicts = {};\n\n  function scan(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {\n    var v;\n    _.forEach(_.range(southPos, southEnd), function(i) {\n      v = south[i];\n      if (g.node(v).dummy) {\n        _.forEach(g.predecessors(v), function(u) {\n          var uNode = g.node(u);\n          if (uNode.dummy &&\n              (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder)) {\n            addConflict(conflicts, u, v);\n          }\n        });\n      }\n    });\n  }\n\n\n  function visitLayer(north, south) {\n    var prevNorthPos = -1,\n      nextNorthPos,\n      southPos = 0;\n\n    _.forEach(south, function(v, southLookahead) {\n      if (g.node(v).dummy === \"border\") {\n        var predecessors = g.predecessors(v);\n        if (predecessors.length) {\n          nextNorthPos = g.node(predecessors[0]).order;\n          scan(south, southPos, southLookahead, prevNorthPos, nextNorthPos);\n          southPos = southLookahead;\n          prevNorthPos = nextNorthPos;\n        }\n      }\n      scan(south, southPos, south.length, nextNorthPos, north.length);\n    });\n\n    return south;\n  }\n\n  _.reduce(layering, visitLayer);\n  return conflicts;\n}\n\nfunction findOtherInnerSegmentNode(g, v) {\n  if (g.node(v).dummy) {\n    return _.find(g.predecessors(v), function(u) {\n      return g.node(u).dummy;\n    });\n  }\n}\n\nfunction addConflict(conflicts, v, w) {\n  if (v > w) {\n    var tmp = v;\n    v = w;\n    w = tmp;\n  }\n\n  var conflictsV = conflicts[v];\n  if (!conflictsV) {\n    conflicts[v] = conflictsV = {};\n  }\n  conflictsV[w] = true;\n}\n\nfunction hasConflict(conflicts, v, w) {\n  if (v > w) {\n    var tmp = v;\n    v = w;\n    w = tmp;\n  }\n  return _.has(conflicts[v], w);\n}\n\n/*\n * Try to align nodes into vertical \"blocks\" where possible. This algorithm\n * attempts to align a node with one of its median neighbors. If the edge\n * connecting a neighbor is a type-1 conflict then we ignore that possibility.\n * If a previous node has already formed a block with a node after the node\n * we're trying to form a block with, we also ignore that possibility - our\n * blocks would be split in that scenario.\n */\nfunction verticalAlignment(g, layering, conflicts, neighborFn) {\n  var root = {},\n    align = {},\n    pos = {};\n\n  // We cache the position here based on the layering because the graph and\n  // layering may be out of sync. The layering matrix is manipulated to\n  // generate different extreme alignments.\n  _.forEach(layering, function(layer) {\n    _.forEach(layer, function(v, order) {\n      root[v] = v;\n      align[v] = v;\n      pos[v] = order;\n    });\n  });\n\n  _.forEach(layering, function(layer) {\n    var prevIdx = -1;\n    _.forEach(layer, function(v) {\n      var ws = neighborFn(v);\n      if (ws.length) {\n        ws = _.sortBy(ws, function(w) { return pos[w]; });\n        var mp = (ws.length - 1) / 2;\n        for (var i = Math.floor(mp), il = Math.ceil(mp); i <= il; ++i) {\n          var w = ws[i];\n          if (align[v] === v &&\n              prevIdx < pos[w] &&\n              !hasConflict(conflicts, v, w)) {\n            align[w] = v;\n            align[v] = root[v] = root[w];\n            prevIdx = pos[w];\n          }\n        }\n      }\n    });\n  });\n\n  return { root: root, align: align };\n}\n\nfunction horizontalCompaction(g, layering, root, align, reverseSep) {\n  // This portion of the algorithm differs from BK due to a number of problems.\n  // Instead of their algorithm we construct a new block graph and do two\n  // sweeps. The first sweep places blocks with the smallest possible\n  // coordinates. The second sweep removes unused space by moving blocks to the\n  // greatest coordinates without violating separation.\n  var xs = {},\n    blockG = buildBlockGraph(g, layering, root, reverseSep),\n    borderType = reverseSep ? \"borderLeft\" : \"borderRight\";\n\n  function iterate(setXsFunc, nextNodesFunc) {\n    var stack = blockG.nodes();\n    var elem = stack.pop();\n    var visited = {};\n    while (elem) {\n      if (visited[elem]) {\n        setXsFunc(elem);\n      } else {\n        visited[elem] = true;\n        stack.push(elem);\n        stack = stack.concat(nextNodesFunc(elem));\n      }\n\n      elem = stack.pop();\n    }\n  }\n\n  // First pass, assign smallest coordinates\n  function pass1(elem) {\n    xs[elem] = blockG.inEdges(elem).reduce(function(acc, e) {\n      return Math.max(acc, xs[e.v] + blockG.edge(e));\n    }, 0);\n  }\n\n  // Second pass, assign greatest coordinates\n  function pass2(elem) {\n    var min = blockG.outEdges(elem).reduce(function(acc, e) {\n      return Math.min(acc, xs[e.w] - blockG.edge(e));\n    }, Number.POSITIVE_INFINITY);\n\n    var node = g.node(elem);\n    if (min !== Number.POSITIVE_INFINITY && node.borderType !== borderType) {\n      xs[elem] = Math.max(xs[elem], min);\n    }\n  }\n\n  iterate(pass1, blockG.predecessors.bind(blockG));\n  iterate(pass2, blockG.successors.bind(blockG));\n\n  // Assign x coordinates to all nodes\n  _.forEach(align, function(v) {\n    xs[v] = xs[root[v]];\n  });\n\n  return xs;\n}\n\n\nfunction buildBlockGraph(g, layering, root, reverseSep) {\n  var blockGraph = new Graph(),\n    graphLabel = g.graph(),\n    sepFn = sep(graphLabel.nodesep, graphLabel.edgesep, reverseSep);\n\n  _.forEach(layering, function(layer) {\n    var u;\n    _.forEach(layer, function(v) {\n      var vRoot = root[v];\n      blockGraph.setNode(vRoot);\n      if (u) {\n        var uRoot = root[u],\n          prevMax = blockGraph.edge(uRoot, vRoot);\n        blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g, v, u), prevMax || 0));\n      }\n      u = v;\n    });\n  });\n\n  return blockGraph;\n}\n\n/*\n * Returns the alignment that has the smallest width of the given alignments.\n */\nfunction findSmallestWidthAlignment(g, xss) {\n  return _.minBy(_.values(xss), function (xs) {\n    var max = Number.NEGATIVE_INFINITY;\n    var min = Number.POSITIVE_INFINITY;\n\n    _.forIn(xs, function (x, v) {\n      var halfWidth = width(g, v) / 2;\n\n      max = Math.max(x + halfWidth, max);\n      min = Math.min(x - halfWidth, min);\n    });\n\n    return max - min;\n  });\n}\n\n/*\n * Align the coordinates of each of the layout alignments such that\n * left-biased alignments have their minimum coordinate at the same point as\n * the minimum coordinate of the smallest width alignment and right-biased\n * alignments have their maximum coordinate at the same point as the maximum\n * coordinate of the smallest width alignment.\n */\nfunction alignCoordinates(xss, alignTo) {\n  var alignToVals = _.values(alignTo),\n    alignToMin = _.min(alignToVals),\n    alignToMax = _.max(alignToVals);\n\n  _.forEach([\"u\", \"d\"], function(vert) {\n    _.forEach([\"l\", \"r\"], function(horiz) {\n      var alignment = vert + horiz,\n        xs = xss[alignment],\n        delta;\n      if (xs === alignTo) return;\n\n      var xsVals = _.values(xs);\n      delta = horiz === \"l\" ? alignToMin - _.min(xsVals) : alignToMax - _.max(xsVals);\n\n      if (delta) {\n        xss[alignment] = _.mapValues(xs, function(x) { return x + delta; });\n      }\n    });\n  });\n}\n\nfunction balance(xss, align) {\n  return _.mapValues(xss.ul, function(ignore, v) {\n    if (align) {\n      return xss[align.toLowerCase()][v];\n    } else {\n      var xs = _.sortBy(_.map(xss, v));\n      return (xs[1] + xs[2]) / 2;\n    }\n  });\n}\n\nfunction positionX(g) {\n  var layering = util.buildLayerMatrix(g);\n  var conflicts = _.merge(\n    findType1Conflicts(g, layering),\n    findType2Conflicts(g, layering));\n\n  var xss = {};\n  var adjustedLayering;\n  _.forEach([\"u\", \"d\"], function(vert) {\n    adjustedLayering = vert === \"u\" ? layering : _.values(layering).reverse();\n    _.forEach([\"l\", \"r\"], function(horiz) {\n      if (horiz === \"r\") {\n        adjustedLayering = _.map(adjustedLayering, function(inner) {\n          return _.values(inner).reverse();\n        });\n      }\n\n      var neighborFn = (vert === \"u\" ? g.predecessors : g.successors).bind(g);\n      var align = verticalAlignment(g, adjustedLayering, conflicts, neighborFn);\n      var xs = horizontalCompaction(g, adjustedLayering,\n        align.root, align.align, horiz === \"r\");\n      if (horiz === \"r\") {\n        xs = _.mapValues(xs, function(x) { return -x; });\n      }\n      xss[vert + horiz] = xs;\n    });\n  });\n\n  var smallestWidth = findSmallestWidthAlignment(g, xss);\n  alignCoordinates(xss, smallestWidth);\n  return balance(xss, g.graph().align);\n}\n\nfunction sep(nodeSep, edgeSep, reverseSep) {\n  return function(g, v, w) {\n    var vLabel = g.node(v);\n    var wLabel = g.node(w);\n    var sum = 0;\n    var delta;\n\n    sum += vLabel.width / 2;\n    if (_.has(vLabel, \"labelpos\")) {\n      switch (vLabel.labelpos.toLowerCase()) {\n      case \"l\": delta = -vLabel.width / 2; break;\n      case \"r\": delta = vLabel.width / 2; break;\n      }\n    }\n    if (delta) {\n      sum += reverseSep ? delta : -delta;\n    }\n    delta = 0;\n\n    sum += (vLabel.dummy ? edgeSep : nodeSep) / 2;\n    sum += (wLabel.dummy ? edgeSep : nodeSep) / 2;\n\n    sum += wLabel.width / 2;\n    if (_.has(wLabel, \"labelpos\")) {\n      switch (wLabel.labelpos.toLowerCase()) {\n      case \"l\": delta = wLabel.width / 2; break;\n      case \"r\": delta = -wLabel.width / 2; break;\n      }\n    }\n    if (delta) {\n      sum += reverseSep ? delta : -delta;\n    }\n    delta = 0;\n\n    return sum;\n  };\n}\n\nfunction width(g, v) {\n  return g.node(v).width;\n}\n"],"names":["require$$0","require$$1","require$$2"],"mappings":"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","x_google_ignoreList":[0]}