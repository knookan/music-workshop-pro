import { cloneDeep, get, isEqual, isPlainObject } from 'lodash-es';
/**
 * Recursively applies properties from 'source' to 'target' and collects changes.
 *
 * @param target - The object to be updated
 * @param source - The source object containing partial updates
 * @param basePath - Current path prefix for nested properties
 * @param options - Configuration options
 */
export function applyOptionUpdates(target, source, basePath = '', options) {
    const { bubbleUp = false, collector } = options !== null && options !== void 0 ? options : {};
    // Set to store unique parent paths that need notification
    const parentPathsToNotify = new Set();
    applyOptionUpdatesInternal(target, source, basePath, collector, bubbleUp, parentPathsToNotify);
    // Bubbling notification: from the deepest parent path to the shallowest
    if (bubbleUp && collector && parentPathsToNotify.size > 0) {
        // Sort by path depth in descending order (deepest first)
        const sortedPaths = Array.from(parentPathsToNotify).sort((a, b) => {
            const depthA = a === '' ? 0 : a.split('.').length;
            const depthB = b === '' ? 0 : b.split('.').length;
            return depthB - depthA;
        });
        for (const parentPath of sortedPaths) {
            const newVal = parentPath ? get(target, parentPath) : target;
            // For parent paths, we provide the cloned new value.
            // oldVal is passed as undefined as tracking branch node state is complex.
            collector(parentPath, cloneDeep(newVal), undefined);
        }
    }
}
function applyOptionUpdatesInternal(target, source, basePath, collector, bubbleUp, parentPathsToNotify) {
    Object.keys(source).forEach((key) => {
        const fullPath = basePath ? `${basePath}.${key}` : key;
        const updateValue = source[key];
        const oldValue = target[key];
        if (updateValue === undefined) {
            delete target[key];
            collector === null || collector === void 0 ? void 0 : collector(fullPath, undefined, oldValue);
            if (bubbleUp)
                collectParentPaths(basePath, parentPathsToNotify);
        }
        else if (isPlainObject(updateValue)) {
            if (!isPlainObject(target[key])) {
                target[key] = {};
            }
            applyOptionUpdatesInternal(target[key], updateValue, fullPath, collector, bubbleUp, parentPathsToNotify);
        }
        else {
            target[key] = updateValue;
            if (!isEqual(updateValue, oldValue)) {
                collector === null || collector === void 0 ? void 0 : collector(fullPath, updateValue, oldValue);
                if (bubbleUp)
                    collectParentPaths(basePath, parentPathsToNotify);
            }
        }
    });
}
/**
 * Collects all parent paths of a given path and adds them to the provided set.
 */
function collectParentPaths(path, set) {
    if (!path) {
        set.add(''); // Root path
        return;
    }
    const parts = path.split('.');
    for (let i = parts.length; i >= 0; i--) {
        set.add(parts.slice(0, i).join('.'));
    }
}
