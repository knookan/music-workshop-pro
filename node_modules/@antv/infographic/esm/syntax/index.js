var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { mapWithSchema } from './mapper.js';
import { parseSyntaxToAst } from './parser.js';
import { parseRelationsNode } from './relations.js';
import { DataSchema, DesignSchema, RootSchema, TemplateSchema, ThemeSchema, } from './schema.js';
function normalizeItems(items) {
    var _a;
    const seen = new Set();
    const normalized = [];
    for (let index = items.length - 1; index >= 0; index -= 1) {
        const item = items[index];
        const id = (_a = item.id) !== null && _a !== void 0 ? _a : item.label;
        if (!id) {
            normalized.push(item);
            continue;
        }
        if (seen.has(id))
            continue;
        seen.add(id);
        if (!item.id)
            item.id = id;
        normalized.push(item);
    }
    return normalized.reverse();
}
function resolveTemplate(node, errors) {
    if (!node)
        return undefined;
    const mapped = mapWithSchema(node, TemplateSchema, 'template', errors);
    if (!mapped)
        return undefined;
    if (typeof mapped === 'string')
        return mapped;
    if (typeof mapped === 'object' && typeof mapped.type === 'string') {
        return mapped.type;
    }
    return undefined;
}
export function parseSyntax(input) {
    var _a;
    const { ast, errors } = parseSyntaxToAst(input);
    const warnings = [];
    const options = {};
    const mergedEntries = Object.assign({}, ast.entries);
    const infographicNode = ast.entries.infographic;
    let templateFromInfographic;
    if (infographicNode && infographicNode.kind === 'object') {
        if (infographicNode.value)
            templateFromInfographic = infographicNode.value;
        Object.entries(infographicNode.entries).forEach(([key, value]) => {
            if (!(key in mergedEntries))
                mergedEntries[key] = value;
        });
    }
    const allowedRootKeys = new Set([
        'infographic',
        'template',
        'design',
        'data',
        'theme',
        'width',
        'height',
    ]);
    Object.keys(mergedEntries).forEach((key) => {
        if (!allowedRootKeys.has(key)) {
            errors.push({
                path: key,
                line: mergedEntries[key].line,
                code: 'unknown_key',
                message: 'Unknown top-level key.',
                raw: key,
            });
        }
    });
    const templateNode = mergedEntries.template;
    const templateValue = resolveTemplate(templateNode, errors);
    if (templateValue)
        options.template = templateValue;
    if (!options.template && templateFromInfographic) {
        options.template = templateFromInfographic;
    }
    const designNode = mergedEntries.design;
    if (designNode) {
        const design = mapWithSchema(designNode, DesignSchema, 'design', errors);
        if (design)
            options.design = design;
    }
    const dataNode = mergedEntries.data;
    if (dataNode) {
        let relationsNode;
        let dataNodeForMapping = dataNode;
        if (dataNode.kind === 'object') {
            const _b = dataNode.entries, { relations } = _b, rest = __rest(_b, ["relations"]);
            relationsNode = relations;
            dataNodeForMapping = Object.assign(Object.assign({}, dataNode), { entries: rest });
        }
        const data = mapWithSchema(dataNodeForMapping, DataSchema, 'data', errors);
        if (data)
            options.data = data;
        if (relationsNode) {
            const parsed = parseRelationsNode(relationsNode, errors, 'data.relations');
            if (parsed.relations.length > 0 || parsed.items.length > 0) {
                const current = ((_a = options.data) !== null && _a !== void 0 ? _a : {});
                const existingItems = Array.isArray(current.items)
                    ? current.items
                    : [];
                const normalizedItems = normalizeItems(existingItems);
                const itemMap = new Map();
                normalizedItems.forEach((item) => {
                    if (item.id)
                        itemMap.set(item.id, item);
                });
                parsed.items.forEach((item) => {
                    const existing = itemMap.get(item.id);
                    if (existing) {
                        if (!existing.label && item.label)
                            existing.label = item.label;
                    }
                    else {
                        normalizedItems.push(item);
                        itemMap.set(item.id, item);
                    }
                });
                current.items = normalizedItems;
                current.relations = parsed.relations;
                options.data = current;
            }
        }
    }
    const themeNode = mergedEntries.theme;
    if (themeNode) {
        const theme = mapWithSchema(themeNode, ThemeSchema, 'theme', errors);
        if (theme && typeof theme === 'object') {
            const _c = theme, { type } = _c, rest = __rest(_c, ["type"]);
            if (typeof type === 'string' && type)
                options.theme = type;
            if (Object.keys(rest).length > 0) {
                options.themeConfig = rest;
            }
        }
    }
    const widthNode = mergedEntries.width;
    if (widthNode) {
        const width = mapWithSchema(widthNode, RootSchema.fields.width, 'width', errors);
        if (width !== undefined)
            options.width = width;
    }
    const heightNode = mergedEntries.height;
    if (heightNode) {
        const height = mapWithSchema(heightNode, RootSchema.fields.height, 'height', errors);
        if (height !== undefined)
            options.height = height;
    }
    return {
        options,
        errors,
        warnings,
        ast,
    };
}
