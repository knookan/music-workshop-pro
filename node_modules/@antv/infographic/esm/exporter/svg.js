var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { createElement, getElementByRole, getViewBox, setAttributes, setElementRole, traverse, } from '../utils/index.js';
import { embedFonts } from './font.js';
export function exportToSVGString(svg_1) {
    return __awaiter(this, arguments, void 0, function* (svg, options = {}) {
        const node = yield exportToSVG(svg, options);
        const str = new XMLSerializer().serializeToString(node);
        return 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(str);
    });
}
export function exportToSVG(svg_1) {
    return __awaiter(this, arguments, void 0, function* (svg, options = {}) {
        const { embedResources = true, removeIds = false } = options;
        const clonedSVG = svg.cloneNode(true);
        const { width, height } = getViewBox(svg);
        setAttributes(clonedSVG, { width, height });
        if (removeIds) {
            inlineUseElements(clonedSVG);
            inlineDefsReferences(clonedSVG);
        }
        else {
            yield embedIcons(clonedSVG);
        }
        yield embedFonts(clonedSVG, embedResources);
        cleanSVG(clonedSVG);
        return clonedSVG;
    });
}
function embedIcons(svg) {
    return __awaiter(this, void 0, void 0, function* () {
        const icons = svg.querySelectorAll('use');
        const defs = getDefs(svg);
        icons.forEach((icon) => {
            const href = icon.getAttribute('href');
            if (!href)
                return;
            const existsSymbol = svg.querySelector(href);
            if (!existsSymbol) {
                const symbolElement = document.querySelector(href);
                if (symbolElement)
                    defs.appendChild(symbolElement.cloneNode(true));
            }
        });
    });
}
const iconRole = 'icon-defs';
function getDefs(svg) {
    const defs = getElementByRole(svg, iconRole);
    if (defs)
        return defs;
    const _defs = createElement('defs');
    setElementRole(_defs, iconRole);
    svg.prepend(_defs);
    return _defs;
}
function inlineUseElements(svg) {
    const uses = Array.from(svg.querySelectorAll('use'));
    if (!uses.length)
        return;
    uses.forEach((use) => {
        const href = getUseHref(use);
        if (!href || !href.startsWith('#'))
            return;
        const target = resolveUseTarget(svg, href);
        if (!target || target === use)
            return;
        const replacement = createInlineElement(use, target);
        if (!replacement)
            return;
        use.replaceWith(replacement);
    });
}
function getUseHref(use) {
    var _a;
    return (_a = use.getAttribute('href')) !== null && _a !== void 0 ? _a : use.getAttribute('xlink:href');
}
function resolveUseTarget(svg, href) {
    const localTarget = svg.querySelector(href);
    if (localTarget)
        return localTarget;
    const docTarget = document.querySelector(href);
    return docTarget;
}
function createInlineElement(use, target) {
    const tag = target.tagName.toLowerCase();
    if (tag === 'symbol') {
        return materializeSymbol(use, target);
    }
    if (tag === 'svg') {
        return materializeSVG(use, target);
    }
    return materializeElement(use, target);
}
function materializeSymbol(use, symbol) {
    const symbolClone = symbol.cloneNode(true);
    const svg = createElement('svg');
    applyAttributes(svg, symbolClone, new Set(['id']));
    applyAttributes(svg, use, new Set(['href', 'xlink:href']));
    while (symbolClone.firstChild) {
        svg.appendChild(symbolClone.firstChild);
    }
    return svg;
}
function materializeSVG(use, source) {
    const clone = source.cloneNode(true);
    clone.removeAttribute('id');
    applyAttributes(clone, use, new Set(['href', 'xlink:href']));
    return clone;
}
function materializeElement(use, source) {
    const clone = source.cloneNode(true);
    clone.removeAttribute('id');
    const wrapper = createElement('g');
    applyAttributes(wrapper, use, new Set(['href', 'xlink:href', 'x', 'y', 'width', 'height', 'transform']));
    const transform = buildUseTransform(use);
    if (transform) {
        wrapper.setAttribute('transform', transform);
    }
    wrapper.appendChild(clone);
    return wrapper;
}
function buildUseTransform(use) {
    var _a;
    const x = use.getAttribute('x');
    const y = use.getAttribute('y');
    const translate = x || y ? `translate(${x !== null && x !== void 0 ? x : 0} ${y !== null && y !== void 0 ? y : 0})` : '';
    const transform = (_a = use.getAttribute('transform')) !== null && _a !== void 0 ? _a : '';
    if (translate && transform)
        return `${translate} ${transform}`;
    return translate || transform || null;
}
function applyAttributes(target, source, exclude = new Set()) {
    Array.from(source.attributes).forEach((attr) => {
        if (exclude.has(attr.name))
            return;
        if (attr.name === 'style') {
            mergeStyleAttribute(target, attr.value);
            return;
        }
        if (attr.name === 'class') {
            mergeClassAttribute(target, attr.value);
            return;
        }
        target.setAttribute(attr.name, attr.value);
    });
}
function mergeStyleAttribute(target, value) {
    const current = target.getAttribute('style');
    if (!current) {
        target.setAttribute('style', value);
        return;
    }
    const separator = current.trim().endsWith(';') ? '' : ';';
    target.setAttribute('style', `${current}${separator}${value}`);
}
function mergeClassAttribute(target, value) {
    const current = target.getAttribute('class');
    if (!current) {
        target.setAttribute('class', value);
        return;
    }
    target.setAttribute('class', `${current} ${value}`.trim());
}
const urlRefRegex = /url\(\s*['"]?#([^'")\s]+)['"]?\s*\)/g;
function inlineDefsReferences(svg) {
    const referencedIds = collectReferencedIds(svg);
    if (referencedIds.size === 0) {
        removeDefs(svg);
        return;
    }
    const defsDataUrl = createDefsDataUrl(svg, referencedIds);
    if (!defsDataUrl)
        return;
    traverse(svg, (node) => {
        if (node.tagName.toLowerCase() === 'defs')
            return false;
        const attrs = Array.from(node.attributes);
        attrs.forEach((attr) => {
            const value = attr.value;
            if (!value.includes('url('))
                return;
            const updated = value.replace(urlRefRegex, (_match, id) => {
                const encodedId = encodeURIComponent(id);
                return `url("${defsDataUrl}#${encodedId}")`;
            });
            if (updated !== value)
                node.setAttribute(attr.name, updated);
        });
    });
    removeDefs(svg);
}
function collectReferencedIds(svg) {
    const ids = new Set();
    traverse(svg, (node) => {
        if (node.tagName.toLowerCase() === 'defs')
            return false;
        collectIdsFromAttributes(node, (id) => ids.add(id));
    });
    return ids;
}
function collectIdsFromAttributes(node, addId) {
    for (const attr of Array.from(node.attributes)) {
        const value = attr.value;
        if (value.includes('url(')) {
            for (const match of value.matchAll(urlRefRegex)) {
                if (match[1])
                    addId(match[1]);
            }
        }
        if ((attr.name === 'href' || attr.name === 'xlink:href') &&
            value[0] === '#') {
            addId(value.slice(1));
        }
    }
}
function createDefsDataUrl(svg, ids) {
    if (ids.size === 0)
        return null;
    const collected = collectDefElements(svg, ids);
    if (collected.size === 0)
        return null;
    const defsSvg = createElement('svg', {
        xmlns: 'http://www.w3.org/2000/svg',
        'xmlns:xlink': 'http://www.w3.org/1999/xlink',
    });
    const defs = createElement('defs');
    collected.forEach((node) => {
        defs.appendChild(node.cloneNode(true));
    });
    if (!defs.children.length)
        return null;
    defsSvg.appendChild(defs);
    const serialized = new XMLSerializer().serializeToString(defsSvg);
    return 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(serialized);
}
function collectDefElements(svg, ids) {
    const collected = new Map();
    const queue = Array.from(ids);
    const queued = new Set(queue);
    const visited = new Set();
    const enqueue = (id) => {
        if (visited.has(id) || queued.has(id))
            return;
        queue.push(id);
        queued.add(id);
    };
    while (queue.length) {
        const id = queue.shift();
        if (visited.has(id))
            continue;
        visited.add(id);
        const selector = `#${escapeCssId(id)}`;
        const target = svg.querySelector(selector);
        if (!target)
            continue;
        collected.set(id, target);
        traverse(target, (node) => {
            collectIdsFromAttributes(node, enqueue);
        });
    }
    return collected;
}
function escapeCssId(id) {
    if (globalThis.CSS && typeof globalThis.CSS.escape === 'function') {
        return globalThis.CSS.escape(id);
    }
    return id.replace(/([!"#$%&'()*+,./:;<=>?@[\]^`{|}~])/g, '\\$1');
}
function removeDefs(svg) {
    const defsList = Array.from(svg.querySelectorAll('defs'));
    defsList.forEach((defs) => defs.remove());
}
function cleanSVG(svg) {
    removeBtnGroup(svg);
    removeTransientContainer(svg);
    removeUselessAttrs(svg);
    clearDataset(svg);
}
function removeBtnGroup(svg) {
    const btnGroup = getElementByRole(svg, "btns-group" /* ElementTypeEnum.BtnsGroup */);
    btnGroup === null || btnGroup === void 0 ? void 0 : btnGroup.remove();
    const btnIconDefs = getElementByRole(svg, 'btn-icon-defs');
    btnIconDefs === null || btnIconDefs === void 0 ? void 0 : btnIconDefs.remove();
}
function removeTransientContainer(svg) {
    const transientContainer = svg.querySelector('[data-element-type=transient-container]');
    transientContainer === null || transientContainer === void 0 ? void 0 : transientContainer.remove();
}
function removeUselessAttrs(svg) {
    const groups = svg.querySelectorAll('g');
    groups.forEach((group) => {
        group.removeAttribute('x');
        group.removeAttribute('y');
        group.removeAttribute('width');
        group.removeAttribute('height');
    });
}
function clearDataset(svg) {
    traverse(svg, (node) => {
        for (const key in node.dataset) {
            delete node.dataset[key];
        }
    });
}
